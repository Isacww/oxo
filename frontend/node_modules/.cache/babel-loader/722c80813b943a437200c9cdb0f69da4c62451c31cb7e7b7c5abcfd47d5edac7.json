{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState } from \"react\";\nconst FULL_SIZE = 32; // Fixed full board size\nconst INITIAL_ACTIVE_SIZE = 7; // Initial playable area\nconst EXPANSION_MARGIN = 1; // How close to the edge before expansion\nconst EXPANSION_STEP = 2; // Expand by 2 in each direction\n\nconst useGameLogic = () => {\n  _s();\n  const [board, setBoard] = useState(Array(FULL_SIZE * FULL_SIZE).fill(null));\n  const [currentPlayer, setCurrentPlayer] = useState(\"X\");\n  const [winner, setWinner] = useState(null);\n\n  // Start centered within FULL_SIZE\n  const [activeTopLeft, setActiveTopLeft] = useState({\n    row: Math.floor((FULL_SIZE - INITIAL_ACTIVE_SIZE) / 2),\n    col: Math.floor((FULL_SIZE - INITIAL_ACTIVE_SIZE) / 2)\n  });\n  const [activeSize, setActiveSize] = useState(INITIAL_ACTIVE_SIZE);\n  const handleClick = index => {\n    if (board[index] !== null || winner) return;\n    const row = Math.floor(index / FULL_SIZE);\n    const col = index % FULL_SIZE;\n\n    // Check if the move is outside the active area\n    if (row < activeTopLeft.row || col < activeTopLeft.col || row >= activeTopLeft.row + activeSize || col >= activeTopLeft.col + activeSize) {\n      return;\n    }\n\n    // Expand if needed\n    if (row <= activeTopLeft.row + EXPANSION_MARGIN || col <= activeTopLeft.col + EXPANSION_MARGIN || row >= activeTopLeft.row + activeSize - EXPANSION_MARGIN - 1 || col >= activeTopLeft.col + activeSize - EXPANSION_MARGIN - 1) {\n      expandActiveBoard();\n    }\n\n    // Update board state\n    const newBoard = [...board];\n    newBoard[index] = currentPlayer;\n    setBoard(newBoard);\n    if (checkWinner(newBoard, currentPlayer)) {\n      setWinner(currentPlayer);\n    } else {\n      setCurrentPlayer(currentPlayer === \"X\" ? \"O\" : \"X\");\n    }\n  };\n\n  // Expands the playable board symmetrically\n  const expandActiveBoard = () => {\n    let newSize = activeSize + EXPANSION_STEP;\n    if (newSize > FULL_SIZE) newSize = FULL_SIZE;\n    let newTopLeft = {\n      row: Math.max(0, activeTopLeft.row - EXPANSION_STEP / 2),\n      col: Math.max(0, activeTopLeft.col - EXPANSION_STEP / 2)\n    };\n    setActiveSize(newSize);\n    setActiveTopLeft(newTopLeft);\n  };\n\n  // Checks for 5-in-a-row win condition\n  const checkWinner = (board, currentPlayer) => {\n    const grid = [];\n\n    // Convert 1D board into a 2D grid\n    for (let row = 0; row < FULL_SIZE; row++) {\n      grid.push(board.slice(row * FULL_SIZE, (row + 1) * FULL_SIZE));\n    }\n    const checkLine = cells => {\n      for (let i = 0; i <= cells.length - 5; i++) {\n        if (cells.slice(i, i + 5).every(cell => cell === currentPlayer)) {\n          return true;\n        }\n      }\n      return false;\n    };\n\n    // Check rows\n    for (let row = activeTopLeft.row; row < activeTopLeft.row + activeSize; row++) {\n      if (checkLine(grid[row].slice(activeTopLeft.col, activeTopLeft.col + activeSize))) return true;\n    }\n\n    // Check columns\n    for (let col = activeTopLeft.col; col < activeTopLeft.col + activeSize; col++) {\n      let column = grid.map(row => row[col]).slice(activeTopLeft.row, activeTopLeft.row + activeSize);\n      if (checkLine(column)) return true;\n    }\n\n    // Check diagonals\n    for (let startRow = activeTopLeft.row; startRow <= activeTopLeft.row + activeSize - 5; startRow++) {\n      for (let startCol = activeTopLeft.col; startCol <= activeTopLeft.col + activeSize - 5; startCol++) {\n        let mainDiagonal = [];\n        let antiDiagonal = [];\n        for (let i = 0; i < 5; i++) {\n          var _grid, _grid2;\n          mainDiagonal.push((_grid = grid[startRow + i]) === null || _grid === void 0 ? void 0 : _grid[startCol + i]);\n          antiDiagonal.push((_grid2 = grid[startRow + i]) === null || _grid2 === void 0 ? void 0 : _grid2[startCol + 4 - i]);\n        }\n        if (checkLine(mainDiagonal) || checkLine(antiDiagonal)) return true;\n      }\n    }\n    return false;\n  };\n  const resetGame = () => {\n    setBoard(Array(FULL_SIZE * FULL_SIZE).fill(null));\n    setCurrentPlayer(\"X\");\n    setWinner(null);\n    setActiveSize(INITIAL_ACTIVE_SIZE);\n    setActiveTopLeft({\n      row: Math.floor((FULL_SIZE - INITIAL_ACTIVE_SIZE) / 2),\n      col: Math.floor((FULL_SIZE - INITIAL_ACTIVE_SIZE) / 2)\n    });\n  };\n  return {\n    board,\n    currentPlayer,\n    winner,\n    activeSize,\n    activeTopLeft,\n    handleClick,\n    resetGame\n  };\n};\n_s(useGameLogic, \"92vjgyFwtktERzqc2YTSD+kYFZ8=\");\nexport default useGameLogic;","map":{"version":3,"names":["useState","FULL_SIZE","INITIAL_ACTIVE_SIZE","EXPANSION_MARGIN","EXPANSION_STEP","useGameLogic","_s","board","setBoard","Array","fill","currentPlayer","setCurrentPlayer","winner","setWinner","activeTopLeft","setActiveTopLeft","row","Math","floor","col","activeSize","setActiveSize","handleClick","index","expandActiveBoard","newBoard","checkWinner","newSize","newTopLeft","max","grid","push","slice","checkLine","cells","i","length","every","cell","column","map","startRow","startCol","mainDiagonal","antiDiagonal","_grid","_grid2","resetGame"],"sources":["C:/Users/issen/programmingCourses/own/oxo/oxo/frontend/src/hooks/GameLogicHook.js"],"sourcesContent":["import { useState } from \"react\";\r\n\r\nconst FULL_SIZE = 32; // Fixed full board size\r\nconst INITIAL_ACTIVE_SIZE = 7; // Initial playable area\r\nconst EXPANSION_MARGIN = 1; // How close to the edge before expansion\r\nconst EXPANSION_STEP = 2; // Expand by 2 in each direction\r\n\r\nconst useGameLogic = () => {\r\n    const [board, setBoard] = useState(Array(FULL_SIZE * FULL_SIZE).fill(null));\r\n    const [currentPlayer, setCurrentPlayer] = useState(\"X\");\r\n    const [winner, setWinner] = useState(null);\r\n    \r\n    // Start centered within FULL_SIZE\r\n    const [activeTopLeft, setActiveTopLeft] = useState({\r\n        row: Math.floor((FULL_SIZE - INITIAL_ACTIVE_SIZE) / 2),\r\n        col: Math.floor((FULL_SIZE - INITIAL_ACTIVE_SIZE) / 2),\r\n    });\r\n    \r\n    const [activeSize, setActiveSize] = useState(INITIAL_ACTIVE_SIZE);\r\n\r\n    const handleClick = (index) => {\r\n        if (board[index] !== null || winner) return;\r\n\r\n        const row = Math.floor(index / FULL_SIZE);\r\n        const col = index % FULL_SIZE;\r\n\r\n        // Check if the move is outside the active area\r\n        if (\r\n            row < activeTopLeft.row ||\r\n            col < activeTopLeft.col ||\r\n            row >= activeTopLeft.row + activeSize ||\r\n            col >= activeTopLeft.col + activeSize\r\n        ) {\r\n            return;\r\n        }\r\n\r\n        // Expand if needed\r\n        if (\r\n            row <= activeTopLeft.row + EXPANSION_MARGIN ||\r\n            col <= activeTopLeft.col + EXPANSION_MARGIN ||\r\n            row >= activeTopLeft.row + activeSize - EXPANSION_MARGIN - 1 ||\r\n            col >= activeTopLeft.col + activeSize - EXPANSION_MARGIN - 1\r\n        ) {\r\n            expandActiveBoard();\r\n        }\r\n\r\n        // Update board state\r\n        const newBoard = [...board];\r\n        newBoard[index] = currentPlayer;\r\n        setBoard(newBoard);\r\n\r\n        if (checkWinner(newBoard, currentPlayer)) {\r\n            setWinner(currentPlayer);\r\n        } else {\r\n            setCurrentPlayer(currentPlayer === \"X\" ? \"O\" : \"X\");\r\n        }\r\n    };\r\n\r\n    // Expands the playable board symmetrically\r\n    const expandActiveBoard = () => {\r\n        let newSize = activeSize + EXPANSION_STEP;\r\n        if (newSize > FULL_SIZE) newSize = FULL_SIZE;\r\n\r\n        let newTopLeft = {\r\n            row: Math.max(0, activeTopLeft.row - EXPANSION_STEP / 2),\r\n            col: Math.max(0, activeTopLeft.col - EXPANSION_STEP / 2),\r\n        };\r\n\r\n        setActiveSize(newSize);\r\n        setActiveTopLeft(newTopLeft);\r\n    };\r\n\r\n    // Checks for 5-in-a-row win condition\r\n    const checkWinner = (board, currentPlayer) => {\r\n        const grid = [];\r\n        \r\n        // Convert 1D board into a 2D grid\r\n        for (let row = 0; row < FULL_SIZE; row++) {\r\n            grid.push(board.slice(row * FULL_SIZE, (row + 1) * FULL_SIZE));\r\n        }\r\n\r\n        const checkLine = (cells) => {\r\n            for (let i = 0; i <= cells.length - 5; i++) {\r\n                if (cells.slice(i, i + 5).every(cell => cell === currentPlayer)) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        };\r\n\r\n        // Check rows\r\n        for (let row = activeTopLeft.row; row < activeTopLeft.row + activeSize; row++) {\r\n            if (checkLine(grid[row].slice(activeTopLeft.col, activeTopLeft.col + activeSize))) return true;\r\n        }\r\n\r\n        // Check columns\r\n        for (let col = activeTopLeft.col; col < activeTopLeft.col + activeSize; col++) {\r\n            let column = grid.map(row => row[col]).slice(activeTopLeft.row, activeTopLeft.row + activeSize);\r\n            if (checkLine(column)) return true;\r\n        }\r\n\r\n        // Check diagonals\r\n        for (let startRow = activeTopLeft.row; startRow <= activeTopLeft.row + activeSize - 5; startRow++) {\r\n            for (let startCol = activeTopLeft.col; startCol <= activeTopLeft.col + activeSize - 5; startCol++) {\r\n                let mainDiagonal = [];\r\n                let antiDiagonal = [];\r\n\r\n                for (let i = 0; i < 5; i++) {\r\n                    mainDiagonal.push(grid[startRow + i]?.[startCol + i]);\r\n                    antiDiagonal.push(grid[startRow + i]?.[startCol + 4 - i]);\r\n                }\r\n\r\n                if (checkLine(mainDiagonal) || checkLine(antiDiagonal)) return true;\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n\r\n    const resetGame = () => {\r\n        setBoard(Array(FULL_SIZE * FULL_SIZE).fill(null));\r\n        setCurrentPlayer(\"X\");\r\n        setWinner(null);\r\n        setActiveSize(INITIAL_ACTIVE_SIZE);\r\n        setActiveTopLeft({\r\n            row: Math.floor((FULL_SIZE - INITIAL_ACTIVE_SIZE) / 2),\r\n            col: Math.floor((FULL_SIZE - INITIAL_ACTIVE_SIZE) / 2),\r\n        });\r\n    };\r\n\r\n    return { board, currentPlayer, winner, activeSize, activeTopLeft, handleClick, resetGame };\r\n};\r\n\r\nexport default useGameLogic;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}