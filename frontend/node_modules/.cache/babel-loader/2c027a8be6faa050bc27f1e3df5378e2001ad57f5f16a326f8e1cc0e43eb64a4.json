{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState } from \"react\";\nconst {\n  user\n} = useUser();\nconst DEFAULT_FULL_SIZE = 40; // You can now set this dynamically when initializing the hook\nconst INITIAL_ACTIVE_SIZE = 9;\nconst EXPANSION_STEP = 2;\nconst useGameLogic = (fullSize = DEFAULT_FULL_SIZE) => {\n  _s();\n  if (!Number.isInteger(fullSize) || fullSize <= 0) {\n    throw new Error(\"Invalid fullSize value. Must be a positive integer.\");\n  }\n  const [board, setBoard] = useState(Array(fullSize * fullSize).fill(null));\n  const [currentPlayer, setCurrentPlayer] = useState(\"X\");\n  const [winner, setWinner] = useState(null);\n  const {\n    user,\n    setRank\n  } = useUser(); // Get user context\n\n  const [activeTopLeft, setActiveTopLeft] = useState({\n    row: Math.floor((fullSize - INITIAL_ACTIVE_SIZE) / 2),\n    col: Math.floor((fullSize - INITIAL_ACTIVE_SIZE) / 2)\n  });\n  const [activeSize, setActiveSize] = useState(INITIAL_ACTIVE_SIZE);\n  const handleClick = index => {\n    if (winner) return; // Stop clicks after win\n\n    // Convert active board index to row/col\n    const row = Math.floor(index / activeSize);\n    const col = index % activeSize;\n\n    // Map to full board space\n    const fullRow = activeTopLeft.row + row;\n    const fullCol = activeTopLeft.col + col;\n    const fullIndex = fullRow * fullSize + fullCol;\n    if (board[fullIndex] !== null) return; // Prevent overwriting\n\n    // Create a new updated board first\n    const newBoard = [...board];\n    newBoard[fullIndex] = currentPlayer;\n\n    // Check for a winner BEFORE setting state\n    if (checkWinner(newBoard, currentPlayer)) {\n      setWinner(currentPlayer);\n      updateRank();\n    }\n\n    // Update state\n    setBoard(newBoard);\n\n    // Expand board if needed\n    if (row < EXPANSION_STEP || col < EXPANSION_STEP || row >= activeSize - EXPANSION_STEP || col >= activeSize - EXPANSION_STEP) {\n      expandActiveBoard();\n    }\n\n    // Only update the player if there's no winner\n    if (!checkWinner(newBoard, currentPlayer)) {\n      setCurrentPlayer(currentPlayer === \"X\" ? \"O\" : \"X\");\n    }\n  };\n  const expandActiveBoard = () => {\n    if (activeSize + EXPANSION_STEP * 2 <= fullSize) {\n      setActiveSize(activeSize + EXPANSION_STEP * 2);\n      setActiveTopLeft({\n        row: Math.max(activeTopLeft.row - EXPANSION_STEP, 0),\n        col: Math.max(activeTopLeft.col - EXPANSION_STEP, 0)\n      });\n    }\n  };\n  const checkWinner = (board, currentPlayer) => {\n    const grid = [];\n    for (let row = 0; row < fullSize; row++) {\n      grid.push(board.slice(row * fullSize, (row + 1) * fullSize));\n    }\n    const checkLine = cells => {\n      for (let i = 0; i <= cells.length - 5; i++) {\n        if (cells.slice(i, i + 5).every(cell => cell === currentPlayer)) {\n          return true;\n        }\n      }\n      return false;\n    };\n    for (let row = activeTopLeft.row; row < activeTopLeft.row + activeSize; row++) {\n      if (checkLine(grid[row].slice(activeTopLeft.col, activeTopLeft.col + activeSize))) return true;\n    }\n    for (let col = activeTopLeft.col; col < activeTopLeft.col + activeSize; col++) {\n      let column = grid.map(row => row[col]).slice(activeTopLeft.row, activeTopLeft.row + activeSize);\n      if (checkLine(column)) return true;\n    }\n    for (let startRow = activeTopLeft.row; startRow <= activeTopLeft.row + activeSize - 5; startRow++) {\n      for (let startCol = activeTopLeft.col; startCol <= activeTopLeft.col + activeSize - 5; startCol++) {\n        let mainDiagonal = [];\n        let antiDiagonal = [];\n        for (let i = 0; i < 5; i++) {\n          var _grid, _grid2;\n          mainDiagonal.push((_grid = grid[startRow + i]) === null || _grid === void 0 ? void 0 : _grid[startCol + i]);\n          antiDiagonal.push((_grid2 = grid[startRow + i]) === null || _grid2 === void 0 ? void 0 : _grid2[startCol + 4 - i]);\n        }\n        if (checkLine(mainDiagonal) || checkLine(antiDiagonal)) return true;\n      }\n    }\n    return false;\n  };\n  const updateRank = () => {\n    setRank(prevRank => prevRank + Math.abs(prevRank) % 100); // Correct rank calculation\n  };\n  const resetGame = () => {\n    setBoard(Array(fullSize * fullSize).fill(null));\n    setCurrentPlayer(\"X\");\n    setWinner(null);\n    setActiveSize(INITIAL_ACTIVE_SIZE);\n    setActiveTopLeft({\n      row: Math.floor((fullSize - INITIAL_ACTIVE_SIZE) / 2),\n      col: Math.floor((fullSize - INITIAL_ACTIVE_SIZE) / 2)\n    });\n  };\n  return {\n    board,\n    fullSize,\n    currentPlayer,\n    winner,\n    activeSize,\n    activeTopLeft,\n    handleClick,\n    resetGame\n  };\n};\n_s(useGameLogic, \"wmafcZDdXbKwSGfHA6qNcYY+ebE=\", true);\nexport default useGameLogic;","map":{"version":3,"names":["useState","user","useUser","DEFAULT_FULL_SIZE","INITIAL_ACTIVE_SIZE","EXPANSION_STEP","useGameLogic","fullSize","_s","Number","isInteger","Error","board","setBoard","Array","fill","currentPlayer","setCurrentPlayer","winner","setWinner","setRank","activeTopLeft","setActiveTopLeft","row","Math","floor","col","activeSize","setActiveSize","handleClick","index","fullRow","fullCol","fullIndex","newBoard","checkWinner","updateRank","expandActiveBoard","max","grid","push","slice","checkLine","cells","i","length","every","cell","column","map","startRow","startCol","mainDiagonal","antiDiagonal","_grid","_grid2","prevRank","abs","resetGame"],"sources":["C:/Users/issen/programmingCourses/own/oxo/oxo/frontend/src/hooks/GameLogicHook.js"],"sourcesContent":["import { useState } from \"react\";\r\nconst { user } = useUser();\r\n\r\nconst DEFAULT_FULL_SIZE = 40; // You can now set this dynamically when initializing the hook\r\nconst INITIAL_ACTIVE_SIZE = 9; \r\nconst EXPANSION_STEP = 2;\r\n\r\nconst useGameLogic = (fullSize = DEFAULT_FULL_SIZE) => {\r\n        if (!Number.isInteger(fullSize) || fullSize <= 0) {\r\n            throw new Error(\"Invalid fullSize value. Must be a positive integer.\");\r\n        }    \r\n    const [board, setBoard] = useState(Array(fullSize * fullSize).fill(null));\r\n    const [currentPlayer, setCurrentPlayer] = useState(\"X\");\r\n    const [winner, setWinner] = useState(null);\r\n    const { user, setRank } = useUser(); // Get user context\r\n    \r\n    const [activeTopLeft, setActiveTopLeft] = useState({\r\n        row: Math.floor((fullSize - INITIAL_ACTIVE_SIZE) / 2),\r\n        col: Math.floor((fullSize - INITIAL_ACTIVE_SIZE) / 2),\r\n    });\r\n\r\n    const [activeSize, setActiveSize] = useState(INITIAL_ACTIVE_SIZE);\r\n\r\n    const handleClick = (index) => {\r\n        if (winner) return; // Stop clicks after win\r\n    \r\n        // Convert active board index to row/col\r\n        const row = Math.floor(index / activeSize);\r\n        const col = index % activeSize;\r\n    \r\n        // Map to full board space\r\n        const fullRow = activeTopLeft.row + row;\r\n        const fullCol = activeTopLeft.col + col;\r\n        const fullIndex = fullRow * fullSize + fullCol;\r\n    \r\n        if (board[fullIndex] !== null) return; // Prevent overwriting\r\n    \r\n        // Create a new updated board first\r\n        const newBoard = [...board];\r\n        newBoard[fullIndex] = currentPlayer;\r\n    \r\n        // Check for a winner BEFORE setting state\r\n        if (checkWinner(newBoard, currentPlayer)) {\r\n            setWinner(currentPlayer);\r\n            updateRank()\r\n        }\r\n    \r\n        // Update state\r\n        setBoard(newBoard);\r\n    \r\n        // Expand board if needed\r\n        if (\r\n            row < EXPANSION_STEP || col < EXPANSION_STEP ||\r\n            row >= activeSize - EXPANSION_STEP || col >= activeSize - EXPANSION_STEP\r\n        ) {\r\n            expandActiveBoard();\r\n        }\r\n    \r\n        // Only update the player if there's no winner\r\n        if (!checkWinner(newBoard, currentPlayer)) {\r\n            setCurrentPlayer(currentPlayer === \"X\" ? \"O\" : \"X\");\r\n        }\r\n    };\r\n    \r\n    \r\n\r\n    const expandActiveBoard = () => {\r\n        if (activeSize + EXPANSION_STEP * 2 <= fullSize) {\r\n            setActiveSize(activeSize + EXPANSION_STEP * 2);\r\n            setActiveTopLeft({\r\n                row: Math.max(activeTopLeft.row - EXPANSION_STEP, 0),\r\n                col: Math.max(activeTopLeft.col - EXPANSION_STEP, 0),\r\n            });\r\n        }\r\n    };\r\n\r\n    const checkWinner = (board, currentPlayer) => {\r\n        const grid = [];\r\n\r\n        for (let row = 0; row < fullSize; row++) {\r\n            grid.push(board.slice(row * fullSize, (row + 1) * fullSize));\r\n        }\r\n\r\n        const checkLine = (cells) => {\r\n            for (let i = 0; i <= cells.length - 5; i++) {\r\n                if (cells.slice(i, i + 5).every(cell => cell === currentPlayer)) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        };\r\n\r\n        for (let row = activeTopLeft.row; row < activeTopLeft.row + activeSize; row++) {\r\n            if (checkLine(grid[row].slice(activeTopLeft.col, activeTopLeft.col + activeSize))) return true;\r\n        }\r\n\r\n        for (let col = activeTopLeft.col; col < activeTopLeft.col + activeSize; col++) {\r\n            let column = grid.map(row => row[col]).slice(activeTopLeft.row, activeTopLeft.row + activeSize);\r\n            if (checkLine(column)) return true;\r\n        }\r\n\r\n        for (let startRow = activeTopLeft.row; startRow <= activeTopLeft.row + activeSize - 5; startRow++) {\r\n            for (let startCol = activeTopLeft.col; startCol <= activeTopLeft.col + activeSize - 5; startCol++) {\r\n                let mainDiagonal = [];\r\n                let antiDiagonal = [];\r\n\r\n                for (let i = 0; i < 5; i++) {\r\n                    mainDiagonal.push(grid[startRow + i]?.[startCol + i]);\r\n                    antiDiagonal.push(grid[startRow + i]?.[startCol + 4 - i]);\r\n                }\r\n\r\n                if (checkLine(mainDiagonal) || checkLine(antiDiagonal)) return true;\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n\r\n    const updateRank = () => {\r\n        setRank((prevRank) => prevRank + Math.abs(prevRank) % 100); // Correct rank calculation\r\n    };\r\n\r\n    const resetGame = () => {\r\n        setBoard(Array(fullSize * fullSize).fill(null));\r\n        setCurrentPlayer(\"X\");\r\n        setWinner(null);\r\n        setActiveSize(INITIAL_ACTIVE_SIZE);\r\n        setActiveTopLeft({\r\n            row: Math.floor((fullSize - INITIAL_ACTIVE_SIZE) / 2),\r\n            col: Math.floor((fullSize - INITIAL_ACTIVE_SIZE) / 2),\r\n        });\r\n    };\r\n\r\n    return { board, fullSize, currentPlayer, winner, activeSize, activeTopLeft, handleClick, resetGame };\r\n};\r\n\r\nexport default useGameLogic;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}